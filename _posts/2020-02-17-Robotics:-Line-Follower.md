---
layout: post
title:  "Robotics: Line Follower"
description: "My Line Follower proyect in Phyton"
last_modified_at: 2020-02-17
image:
categories: Robotics, Technology
tags: [Robotics, Phyton, cv2, PID]
author: dhrodao
---
# 1. Introduction

For this project I have used CV2 in Phyton for image processing and different logic methods for robots, the robot used has a camera in the front left side of the vehicle (it's a F1 car). First, I have used the most basic of all, case-based programming. The next method of implementation will be through a PID controller. I will be updating this post with the new changes in my proyect.

<figure class="align-center">
  <img src="{{ "/assets/images/blog/escenario.png" | absolute_url }}" alt="Figure 1. Scenario.">
</figure>

## 1.1. What case-based programming is

Case-based control is a relatively simple reactive system. It is an Artificial Intelligence methodology to carry out learning that has achieved good results in many fields of application. As features, a case-based control:
<p>
    · Iterative operation (fast iterations)
</p>
<p>
    · Situation correspondence table
</p>
<p>
    · Allows to react to unforeseen events
</p>
<p>
    · Time does not influence. it's "here and now"
 </p>

## 1.2. What PID controller is

It is a combination of three controllers, proportional (P), derivative (D) and Integrator (I). The P controller reacts notably to high errors, the D controller smooths the error in order the car doesn't start swinging and finally the I controller removes the offsets ocasionated by the other controllers.
<figure class="align-center">
  <img src="{{ '/assets/images/blog/PID.png' | absolute_url }}" alt="RGB image">
  <figcaption>PID ecuation.</figcaption>
</figure>



# 2. Image processing

Before implementing the robot intelligence, we must do a **simple image processing** in order to extract the information from the sensors we have been provided. Firstly, we need to get the **RGB** image from the camera, and convert it to **HSV**. Then, what I have done is, using the cv2 library, create a mask with the line colour and aplying it to the HSV image. Now we have a **binary image**, so we can start extracting information from it.

<figure class="align-center">
  <img src="{{ '/assets/images/blog/rgb.png' | absolute_url }}" alt="RGB image">
  <figcaption>RGB image.</figcaption>

  <img src="{{ '/assets/images/blog/hsv.png' | absolute_url }}" alt="HSV image">
  <figcaption>HSV image.</figcaption>

  <img src="{{ '/assets/images/blog/binary.png' | absolute_url }}" alt="Binary image">
  <figcaption>Binary image.</figcaption>
</figure>

# 3. Case-based implementation

This is the easiest way to perform your logic method. I used an **if-esif** structure contemplating the possible situations in which the car can be involved, I have set the conditions up experimentally.

## 3.1. Way to set the conditions up

I have in account the pixels from my image, count the rigth and left side pixels from the half of the **binary image** and then apply the most suitable condition for the extracted information from the image.

<pre>
  <div class="video-responsive">
    operation with case-based control method
    <iframe  src="https://www.youtube.com/embed/DZe6JDucfn0" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
  </div>
</pre>


# 4. PID controller implementation

First, I needed to change the way I calculate my error (to count pixels in each side of the screen wasn't that efficient). So I thought a new way to calculate the deviation, now I calculate the center of the fotogram and then the center of the red line on the tack, with that I get the car deviation (center - redline_center).
Also, I have programmed a system so the car brakes when it detects a curve and once it's done it increments it's velocity again, by counting the white pixels from some lines of the frame, on the rigth and left, with that i was able to anticipate to the curve and slow down before get the car crashed.
I implemented the PID algorithm and configured each proportionality constant experimentally. The implementation of each one:

<p>
  <strong>· P controller:</strong> just multiplying the deviation error by Kp. It makes the car to steer proportionally to the error.
</p>
<p>
    <strong>· I controller:</strong> save every error in a global n-array where n is the last n-errors, later get it's mean and multiply it by               Ki. This helps to remove the offset generated by P and D.
</p>
<p>
    <strong>· D controller:</strong> it uses the previous error on every iteration, so a global variable is needded in order to save the error for the next iteration. If the error is high it will make the car to turn more and conversely if the error is low and the car is steering to much it will smooth it.
</p>

After many experimental attempts, this is the result:

<pre>
  <div class="video-responsive">
    operation with PID
    <iframe  src="https://www.youtube.com/embed/sEzLuU40e9Y" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
  </div>
</pre>

After all the above, I was looking for a better system for the velocity management, so I decided on implementing a velocity controller using the <em>Integrative</em> and the <em>Proportional</em> parts. I stablished an initial speed, and if the error starts increasing, the car slows down, then it will be recovering its initial speed.
